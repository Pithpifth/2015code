// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.


#include "RotatetoAngle.h"
#include "math.h"

RotatetoAngle::RotatetoAngle(float Angle, float Speed) {
	// Use requires() here to declare subsystem dependencies
	Requires(Robot::driveBaseSub);
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	
	//Make copies of the variables local to the command
	setinitAngle_Alone = Angle;
	setinitSpeed_Alone = Speed;
	
	ANGLE_TOLERANCE_ALONE = 2; // Tolerance in degrees on either side of set angle
	DRIVE_ANGLE_ALONE = 0; // Only causing drive spins in this command - it doesn't need to know angle.  
	DRIVE_X_ALONE = 0; // used for translation magnitude to drive command - not used - stays 0
	DRIVE_Y_ALONE = 0; // used for translation magnitude to drive command - not used - stays 0
	LOOP_IT_CHECK_ALONE = 5; //checks for iterations through loop. Change later depending on robot


	imu_yaw_Alone = 0; // Measurement from the IMU
	IMU_Scaled_Alone = 0; // Translated to a non-wrapping scale (-180 to 180 -> 820 to 1180)

	RotateAxisOverride_Alone = 0; //Joystick value

	setSpeed_Alone = 0; // Saves the rotation speed functional parameter passed in.
	setAngle_Alone = 0; // Saves the commanded go-to angle functional parameter passed in.

	setinitSpeed_Alone = 0; // Initial Set Speed
	setinitAngle_Alone = 0; // Initial Set Angle

	degrees_to_Alone = 0; //degrees to rotate to "Rotato" - Walter 2014
	degrees_to_abs_Alone = 0; //absolute value of degrees_to
	setAngleScaled_Alone = 0; // Converted value of the Commanded Set Angle to linear scale.
	spinDirection_Alone = 1;  // Sets pin direction: 1=Clockwise from robot top, -1=CCW

	RotCmd_Alone = 0; // Direction * Rot Speed passed to drive command.

	TooFarCW_Alone = false; // Robot is further CW than set point: needs to spin CCW
	TooFarCCW_Alone = false; //Robot is further CCW than set point: needs to spin CW

	TooFarCCWDupe_Alone = false;
	TooFarCWDupe_Alone = false; //Basically duplicates of variables above

	isDone_Alone = false; //Flag to OS/WPI to end this command.

	times_through_loop_Alone = 0; //counter for fixing overshooting
}

// Called just before this Command runs the first time
void RotatetoAngle::Initialize() {
	isDone_Alone = false; // Just started - can't be done yet
	printf("\n\nRotateToAngleInit\n\n");

	imu_yaw_Alone = 0;
	IMU_Scaled_Alone = 0;
	times_through_loop_Alone = 0;
	
	setAngleScaled_Alone = 0;
	spinDirection_Alone = 1;
	
	RotCmd_Alone = 0;
	
	//Assume we don't need the robot to spin until proven via measurement.
	TooFarCW_Alone = false;
	TooFarCCW_Alone = false;
}

// Called repeatedly when this Command is scheduled to run
void RotatetoAngle::Execute() {

	RotateAxisOverride_Alone = Robot::oi->getJoystick1()->GetRawAxis(4); //get joystick for override
	//printf("Executing rotate to angle command");	
	
	isDone_Alone = false; // Just started - can't be done yet
	
	//Assume we don't need the robot to spin until proven via measurement.
	TooFarCW_Alone = false;
	TooFarCCW_Alone = false;
	
	printf("\n");
	printf("%f", setSpeed_Alone);
	printf("\n");
	
	//Default to no rotation commanded
	RotCmd_Alone = 0;
	
	//Read the actual Robot Angle from IMU
	imu_yaw_Alone = Robot::driveBaseSub->pRobot_IMU->GetYaw();
	
	//Scale the IMU reading 
	IMU_Scaled_Alone = imu_yaw_Alone + 1000;
	printf("(loop) Scaled IMU %3.2f\n", IMU_Scaled_Alone);
	
	//Scale Set Angle 
	setAngleScaled_Alone = setAngle_Alone + 1000;
	printf("(loop) Scaled Set Angle %3.2f\n", setAngleScaled_Alone);
	
	//set spin direction and degrees to rotate to
	if(IMU_Scaled_Alone > (setAngleScaled_Alone + ANGLE_TOLERANCE_ALONE)) {
		TooFarCW_Alone = true;
		spinDirection_Alone = -1;
		degrees_to_Alone = IMU_Scaled_Alone - setAngleScaled_Alone;
	}
	
	//set spin direction and degrees to rotate to
	if (IMU_Scaled_Alone < (setAngleScaled_Alone - ANGLE_TOLERANCE_ALONE)) {
		TooFarCCW_Alone = true;
		spinDirection_Alone = 1;
		degrees_to_Alone = setAngleScaled_Alone - IMU_Scaled_Alone;
	}

	//setSpeed = .157* pow(1.011, degrees_to_abs); Walter's dream equation
	//Only start spinning if we need to.
	if (TooFarCW_Alone || TooFarCCW_Alone) {
		degrees_to_abs_Alone = fabs(degrees_to_Alone);
		//scale speeds based on degrees. Why not an exponential function? :)
		if(degrees_to_abs_Alone <= 180)
		{
			setSpeed_Alone = 1;
		}
		if(degrees_to_abs_Alone < 90)
		{
			setSpeed_Alone = 0.4;
		}
		if(degrees_to_abs_Alone < 60)
		{
			setSpeed_Alone = 0.3;
		}
		if(degrees_to_abs_Alone < 30)
		{
			setSpeed_Alone = 0.2;
		}
		RotCmd_Alone = spinDirection_Alone * setSpeed_Alone;
		times_through_loop_Alone = 1;
		printf("(loop) SpinCW = %d     SpinCCW = %d     SpinDir = %f     RotCmd = %3.2f\n", TooFarCCW_Alone, TooFarCW_Alone, spinDirection_Alone, RotCmd_Alone);
		printf("\ntimes through loop: %d", times_through_loop_Alone);
		setSpeed_Alone = setinitSpeed_Alone * setSpeed_Alone; //just in case.
	}
		
	// If we didn't need to spin, we can end the command now.
	else {
		printf("\n\n(loop)Didn't need to spin.\n\n");
		if((times_through_loop_Alone == LOOP_IT_CHECK_ALONE) || (times_through_loop_Alone == 0))
		{
			isDone_Alone = true;
			printf("\n\nisDoneAlone = true\n\n");
		}
		//the reason we implement the loop is because it allows us to check if the
		//robot is past the 0 degrees and if it doesn't thenm increment to loop
		//changes the amount of times for different robots.
		times_through_loop_Alone++;
		printf("\ntimes through loop: %d", times_through_loop_Alone);
	}
	Robot::driveBaseSub->MechDrive(DRIVE_X_ALONE, DRIVE_Y_ALONE, RotCmd_Alone, DRIVE_ANGLE_ALONE);
	if(RotateAxisOverride_Alone < 0.20 && RotateAxisOverride_Alone > -0.20)
	{
		RotateAxisOverride_Alone = 0;
	}
	else 
	{
		RotateAxisOverride_Alone = RotateAxisOverride_Alone * fabs(RotateAxisOverride_Alone);
		isDone_Alone = true;
	}
}
// Make this return true when this Command no longer needs to run execute()
bool RotatetoAngle::IsFinished() {
	
	printf("\n\nRan through execute loop.\n\n");
	if(isDone_Alone == true)
	{
		printf("isDone_Alone is true");
	}
	else
	{
		printf("isDone_Alone is false");
	}
	return isDone_Alone;
}

// Called once after isFinished returns true
void RotatetoAngle::End() {

	printf("\n\nActually done with the command\n\n");
	
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void RotatetoAngle::Interrupted() {

	//not sure if it matters if this or any get interrupted - curious if it happens though
	printf("********************Interrupted!!!***********************");	
	

}
