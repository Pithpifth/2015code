// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.


#include "RotatetoAngle.h"

const int ANGLE_TOLERANCE = 10; // Tolerance in degrees on either side of set angle
const int DRIVE_ANGLE = 0; // Only causing drive spins in this command - it doesn't need to know angle.  
const int DRIVE_X = 0; // used for translation magnitude to drive command - not used - stays 0
const int DRIVE_Y = 0; // used for translation magnitude to drive command - not used - stays 0


float imu_yaw = 0; // Measurement from the IMU
float IMU_Scaled = 0; // Translated to a non-wrapping scale (-180 to 180 -> 820 to 1180)

float setSpeed = 0; // Saves the rotation speed functional parameter passed in.
float setAngle = 0; // Saves the commanded go-to angle functional parameter passed in.

float setAngleScaled = 0; // Converted value of the Commanded Set Angle to linear scale.
float spinDirection = 1;  // Sets pin direction: 1=Clockwise from robot top, -1=CCW

float RotCmd = 0; // Direction * Rot Speed passed to drive command.


bool TooFarCW = false; // Robot is further CW than set point: needs to spin CCW
bool TooFarCCW = false; //Robot is further CCW than set point: needs to spin CW

bool isDone = false; //Flag to OS/WPI to end this command.



RotatetoAngle::RotatetoAngle(float Angle, float Speed) {
	// Use requires() here to declare subsystem dependencies
	Requires(Robot::driveBaseSub);
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	
	//Make copies of the variables local to the command
	setAngle = Angle;
	setSpeed = Speed;
	
}

// Called just before this Command runs the first time
void RotatetoAngle::Initialize() {

	isDone = false; // Just started - can't be done yet
	
	printf("\n\nRotateToAngleInit\n\n");

	imu_yaw = 0;
	IMU_Scaled = 0;
	
	setAngleScaled = 0;
	spinDirection = 1;
	
	RotCmd = 0;
	
	//Assume we don't need the robot to spin until proven via measurement.
	TooFarCW = false;
	TooFarCCW = false;
	
}

// Called repeatedly when this Command is scheduled to run
void RotatetoAngle::Execute() {
	
	//Need one of these to be true to get start loop - 
	// Setting both conditions true isnt ever valid, which also prevent unnecessary movements.
	TooFarCW = true;
	TooFarCCW = true;
	//Leave this in for now - shows if command call causes this to be executed once or repeatedly
	printf("If you see this statement repeatedly something is wrong");
		
	while(TooFarCW || TooFarCCW) {
	
		//because this loop takes time to execute, this gives the OS a chance to keep the rest of the system running
		sleep(1);
	
		//Assume we don't need the robot to spin until proven via measurement.
		TooFarCW = false;
		TooFarCCW = false;
		
		//Default to no rotation commanded
		RotCmd = 0;
	
		
		//Read the actual Robot Angle from IMU
		imu_yaw = Robot::driveBaseSub->pRobot_IMU->GetYaw();
		printf("\n(loop) Raw IMU %3.2f\n", imu_yaw);
	
		//Scale the IMU reading 
		IMU_Scaled = imu_yaw + 1000;
		printf("(loop) Scaled IMU %3.2f\n", IMU_Scaled);
		//Scale Set Angle 
		setAngleScaled = setAngle + 1000;
		printf("(loop) Scaled Set Angle %3.2f\n", setAngleScaled);
		
	
		if (IMU_Scaled > (setAngleScaled + ANGLE_TOLERANCE)) {
			TooFarCW = true;
			spinDirection = -1;
		}
	
		if (IMU_Scaled < (setAngleScaled - ANGLE_TOLERANCE)) {;
			TooFarCCW = true;
			spinDirection = 1;
		}
	
		//Only start spinning if we need to.
		if (TooFarCW || TooFarCCW) {
		
			//TooFarCW = false;
			//TooFarCCW = false;
	
			RotCmd = spinDirection * setSpeed;
			
			//This should come out at some point and done properly with real PID
			//If it oscilates, make subsequent direction turns slower to damp it out.
			//Guessing this wont work very well
			//setSpeed = setSpeed * .8;
			
		
			printf("(loop) SpinCW = %d     SpinCCW = %d     SpinDir = %f     RotCmd = %3.2f\n", TooFarCCW, TooFarCW, spinDirection, RotCmd);
			Robot::driveBaseSub->MechDrive(DRIVE_X, DRIVE_Y, RotCmd, DRIVE_ANGLE);
		}
		
		// If we didn't need to spin, we can end the command now.
		else {
		
			TooFarCW = false;
			TooFarCCW = false;
			
			printf("\n\n(loop)Didn't need to spin.\n\n");
			isDone = true;
			Robot::driveBaseSub->MechDrive(DRIVE_X, DRIVE_Y, 0, DRIVE_ANGLE);
		}
		
	}
	
	printf("\n\nSetting isDone=True.\n\n");
	Robot::driveBaseSub->MechDrive(DRIVE_X, DRIVE_Y, 0, DRIVE_ANGLE);
	isDone = true;
}

// Make this return true when this Command no longer needs to run execute()
bool RotatetoAngle::IsFinished() {

	printf("\n\nRotateToAngle Complete!!!\n\n");
	
	return isDone;
}

// Called once after isFinished returns true
void RotatetoAngle::End() {
	
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void RotatetoAngle::Interrupted() {

}
