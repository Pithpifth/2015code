// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.


#include "RotatetoAngle.h"
#include "math.h"

RotatetoAngle::RotatetoAngle(float Angle, float Speed) {
	// Use requires() here to declare subsystem dependencies
	Requires(Robot::driveBaseSub);
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	
	//Make copies of the variables local to the command
	SetInitAngle = Angle;
	MaxScalingSpeed = Speed;
	
	ANGLE_TOLERANCE = 2;
	DRIVE_ANGLE = 0;  
	DRIVE_X = 0;
	DRIVE_Y = 0;
	ROTATE_LOOP_CHECK = 5;
}

// Called just before this Command runs the first time
void RotatetoAngle::Initialize() {
	AutoRotDone = false; // Just started - can't be done yet
	printf("\n\nRotateToAngleInit\n\n");

	IMU_Yaw = 0;
	IMU_Scaled = 0;

	DriverRotateAxisOverride = 0;

	SetSpeed = 0;
	SetAngle = 0; 
	
	MaxScalingSpeed = 0;
	SetInitAngle = 0;

	DegreesToSetPoint = 0;
	DegreesToSetPointAbs = 0;
	SetAngleScaled = 0;
	SpinDirection = 1;

	RotCmd = 0;

	TooFarCW = false;
	TooFarCCW = false;

	AutoRotDone = false;

	TimesThroughLoop = 0;
}

// Called repeatedly when this Command is scheduled to run
void RotatetoAngle::Execute() {

	DriverRotateAxisOverride = Robot::oi->getJoystick1()->GetRawAxis(4); //get joystick for override
	//printf("Executing rotate to angle command");	
	
	AutoRotDone = false; // Just started - can't be done yet
	
	//Assume we don't need the robot to spin until proven via measurement.
	TooFarCW = false;
	TooFarCCW = false;
	
	printf("\n");
	printf("%f", SetSpeed);
	printf("\n");
	
	//Default to no rotation commanded
	RotCmd = 0;
	
	//Read the actual Robot Angle from IMU
	IMU_Yaw = Robot::driveBaseSub->pRobot_IMU->GetYaw();
	
	//Scale the IMU reading 
	IMU_Scaled = IMU_Yaw + 1000;
	printf("(loop) Scaled IMU %3.2f\n", IMU_Scaled);
	
	//Scale Set Angle 
	SetAngleScaled = SetAngle + 1000;
	printf("(loop) Scaled Set Angle %3.2f\n", SetAngleScaled);
	
	//set spin direction and degrees to rotate to
	if(IMU_Scaled > (SetAngleScaled + ANGLE_TOLERANCE)) {
		TooFarCW = true;
		SpinDirection = -1;
		DegreesToSetPoint = IMU_Scaled - SetAngleScaled;
	}
	
	//set spin direction and degrees to rotate to
	if (IMU_Scaled < (SetAngleScaled - ANGLE_TOLERANCE)) {
		TooFarCCW = true;
		SpinDirection = 1;
		DegreesToSetPoint = SetAngleScaled - IMU_Scaled;
	}

	//SetSpeed = .157* pow(1.011, DegreesToSetPointAbs); Walter's dream equation
	//Only start spinning if we need to.
	if (TooFarCW || TooFarCCW) {
		DegreesToSetPointAbs = fabs(DegreesToSetPoint);
		//scale speeds based on degrees. Why not an exponential function? :)
		if(DegreesToSetPointAbs <= 180)
		{
			SetSpeed = 1;
		}
		if(DegreesToSetPointAbs < 90)
		{
			SetSpeed = 0.4;
		}
		if(DegreesToSetPointAbs < 60)
		{
			SetSpeed = 0.3;
		}
		if(DegreesToSetPointAbs < 30)
		{
			SetSpeed = 0.2;
		}
		RotCmd = SpinDirection * SetSpeed;
		TimesThroughLoop = 1;
		printf("(loop) SpinCW = %d     SpinCCW = %d     SpinDir = %d     RotCmd = %3.2f\n", TooFarCCW, TooFarCW, SpinDirection, RotCmd);
		printf("\ntimes through loop: %d", TimesThroughLoop);
		SetSpeed = MaxScalingSpeed * SetSpeed; //just in case.
	}
		
	// If we didn't need to spin, we can end the command now.
	else {
		printf("\n\n(loop)Didn't need to spin.\n\n");
		if((TimesThroughLoop == ROTATE_LOOP_CHECK) || (TimesThroughLoop == 0))
		{
			AutoRotDone = true;
			printf("\n\nAutoRotDone = true\n\n");
		}
		//the reason we implement the loop is because it allows us to check if the
		//robot is past the 0 degrees and if it doesn't thenm increment to loop
		//changes the amount of times for different robots.
		TimesThroughLoop++;
		printf("\ntimes through loop: %d", TimesThroughLoop);
	}
	Robot::driveBaseSub->MechDrive(DRIVE_X, DRIVE_Y, RotCmd, DRIVE_ANGLE);
	if(DriverRotateAxisOverride < 0.20 && DriverRotateAxisOverride > -0.20)
	{
		DriverRotateAxisOverride = 0;
	}
	else 
	{
		DriverRotateAxisOverride = DriverRotateAxisOverride * fabs(DriverRotateAxisOverride);
		AutoRotDone = true;
	}
}
// Make this return true when this Command no longer needs to run execute()
bool RotatetoAngle::IsFinished() {
	
	printf("\n\nRan through execute loop.\n\n");
	if(AutoRotDone == true)
	{
		printf("AutoRotDone is true");
	}
	else
	{
		printf("AutoRotDone is false");
	}
	return AutoRotDone;
}

// Called once after isFinished returns true
void RotatetoAngle::End() {

	printf("\n\nActually done with the command\n\n");
	
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void RotatetoAngle::Interrupted() {

	//not sure if it matters if this or any get interrupted - curious if it happens though
	printf("********************Interrupted!!!***********************");	
	

}
