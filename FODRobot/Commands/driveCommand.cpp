//not including a leading space just to mess with you
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "driveCommand.h"
#include <math.h>

//Joystick Values under here
float XAxis;
float YAxis;
float RotateAxis;

//IMU Variables
float IMU_Yaw;
float SavedIMU;

//Saves IMU_Yaw to other variable
int loop_count;

//Is it moving? I can't tell!
bool isMoving;

const int ANGLE_TOLERANCE = 2; // Tolerance in degrees on either side of set angle
const int DRIVE_ANGLE = 0; // Only causing drive spins in this command - it doesn't need to know angle.  
const int DRIVE_X = 0; // used for translation magnitude to drive command - not used - stays 0
const int DRIVE_Y = 0; // used for translation magnitude to drive command - not used - stays 0
const int LOOP_IT_CHECK = 5; //checks for iterations through loop. Change later depending on robot

float IMU_Scaled = 0; // Translated to a non-wrapping scale (-180 to 180 -> 820 to 1180)

float RotateAxisOverride = 0; //Joystick value

float setSpeed = 0; // Saves the rotation speed functional parameter passed in.
float setAngle = 0; // Saves the commanded go-to angle functional parameter passed in.

float setinitSpeed = 0; // Initial Set Speed
float setinitAngle = 0; // Initial Set Angle

float degrees_to = 0; //degrees to rotate to "Rotato" - Walter 2014
float degrees_to_abs = 0; //absolute value of degrees_to
float setAngleScaled = 0; // Converted value of the Commanded Set Angle to linear scale.
float spinDirection = 1;  // Sets pin direction: 1=Clockwise from robot top, -1=CCW

float RotCmd = 0; // Direction * Rot Speed passed to drive command.
float RotCmdInDrive = 0; //Same as above except for drive command

bool TooFarCW = false; // Robot is further CW than set point: needs to spin CCW
bool TooFarCCW = false; //Robot is further CCW than set point: needs to spin CW

bool isDone = false; //Flag to OS/WPI to end this command.
bool rotateIsDone = true; //Rotate command is done

int times_through_loop = 0; //counter for fixing overshooting

bool button2_pressed = false; //B button on xbox 360 controller

driveCommand::driveCommand() {

	printf("\n In driveCommand::driveCommand()");


	// Use requires() here to declare subsystem dependencies
	// eg. requires(chassis);
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::driveBaseSub);
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	
	
}

// Called just before this Command runs the first time
void driveCommand::Initialize() {

	printf("\n In driveCommand::Initialize()");
	
	//Setting up variables and IMU
	//This makes sure when we enable the robot, the joystick values are already pointing forward. 
	XAxis = 0;
	YAxis = 0;
	RotateAxis = 0;
	
	IMU_Yaw = 0;
	SavedIMU = 0;
	
	loop_count = 0;
	
	isMoving = false;
	
	IMU_Scaled = 0;
	times_through_loop = 0;
	
	setAngleScaled = 0;
	spinDirection = 1;
	
	RotCmd = 0;
	
	//Assume we don't need the robot to spin until proven via measurement.
	TooFarCW = false;
	TooFarCCW = false;
	
	printf("\n Done driveCommand::Initialize()");
	
}

// Called repeatedly when this Command is scheduled to run
void driveCommand::Execute() {

	printf("\n In driveCommand::Execute(");
	
	RotCmdInDrive = 0;
	
	//Calls RotateToAngleDrive if B button on Joystick is pressed
	button2_pressed = Robot::oi->getJoystick1()->GetRawButton(2);
	
	
	//Start if the button is pressed, or if we arent done from previous conditions
	if(((button2_pressed == true) && (rotateIsDone == true)) || (rotateIsDone == false))
	{
		RotCmdInDrive = RotateToAngleDrive(0, 1);
	}
	
	
	//Read current robot orientation angle measured from starting position=0 degrees
	IMU_Yaw = Robot::driveBaseSub->pRobot_IMU->GetYaw();
	SmartDashboard::PutNumber("Angle of Robot", IMU_Yaw);

	
	isMoving = false;
	
	//Getting Joystick Values
	XAxis = Robot::oi->getJoystick1()->GetRawAxis(1);
	YAxis = Robot::oi->getJoystick1()->GetRawAxis(2);
	RotateAxis = Robot::oi->getJoystick1()->GetRawAxis(4);
	
	//Sets up deadbands (this gets rid of the robot moving very slowly
	//even when you are not touching the joystick. Because the joystick
	//is never really at zero it is at for example 0.0389583. This makes
	//sure every joystick is in the range of -0.20 to 0.20 and if it is set all
	//the axis to zero, if not send the current value to the MechDrive function.
	
	//Also squares the values which increases sensitivity, and (mostly) blends out
	//the discontinuity you would have with just the dead band (there's no step from 0 to .2, 
	//the lowest value is 0 to .04 now.
	
	if(XAxis > -0.20 && XAxis < 0.20)
	{
		XAxis = 0;
		isMoving = false;
	}
	else 
	{
		XAxis = XAxis * fabs(XAxis);
		isMoving = true;
	}
	
	if(YAxis > -0.20 &&YAxis < 0.20)
	{
		YAxis = 0;
		isMoving = false;
	}
	else 
	{
		YAxis = YAxis * fabs(YAxis);
		isMoving = true;
	}
	if(RotateAxis > -0.20 && RotateAxis < 0.20)
	{
		RotateAxis = 0;
		isMoving = false;
	}
	else 
	{
		RotateAxis = RotateAxis * fabs(RotateAxis);
		isMoving = true;
	}
	
	SmartDashboard::PutNumber("JoyX", XAxis);
	SmartDashboard::PutNumber("JoyY", YAxis);
	SmartDashboard::PutNumber("JoyRot", RotateAxis);
	
	//Auto Rotation
	if(RotateAxis == 0)
	{
		Robot::driveBaseSub->MechDrive(XAxis,YAxis,RotCmdInDrive,IMU_Yaw);
		printf("\n Command Drive with AutoRotate");
	}
	//Driver rotation
	else 
	{
		Robot::driveBaseSub->MechDrive(XAxis,YAxis,RotateAxis,IMU_Yaw);
		times_through_loop = 0;
		rotateIsDone = true;
		printf("\n Command Drive with Driver / Joystick Rotation (If Any)");
	}
	
	
	printf("\n Leaving driveCommand::Execute()");
	
	
}

float driveCommand::RotateToAngleDrive(float Angle, float Speed) {

	printf("\n In driveCommand::RotateToAngleDrive");
	
	//passes in values
	setinitAngle = Angle;
	setinitSpeed = Speed;
	
	RotateAxisOverride = Robot::oi->getJoystick1()->GetRawAxis(4); //get joystick for override
	
	rotateIsDone = false; // Just started - can't be done yet
	
	//Assume we don't need the robot to spin until proven via measurement.
	TooFarCW = false;
	TooFarCCW = false;
		
	//Default to no rotation commanded
	RotCmd = 0;
	
	//Read the actual Robot Angle from IMU
	IMU_Yaw = Robot::driveBaseSub->pRobot_IMU->GetYaw();
	
	//Scale the IMU reading 
	IMU_Scaled = IMU_Yaw + 1000;
	
	//Scale Set Angle 
	setAngleScaled = setinitAngle + 1000;
	printf("\n(DriveRotateLoop) Scaled IMU %3.2f  Scaled Set Angle %3.2f\n", IMU_Scaled, setAngleScaled);
	
	//set spin direction and degrees to rotate to
	if(IMU_Scaled > (setAngleScaled + ANGLE_TOLERANCE)) {
		TooFarCW = true;
		spinDirection = -1;
		degrees_to = IMU_Scaled - setAngleScaled;
	}
	
	//set spin direction and degrees to rotate to
	if (IMU_Scaled < (setAngleScaled - ANGLE_TOLERANCE)) {
		TooFarCCW = true;
		spinDirection = 1;
		degrees_to = setAngleScaled - IMU_Scaled;
	}


	//Only start spinning if we need to.
	if (TooFarCW || TooFarCCW) {
		degrees_to_abs = fabs(degrees_to);
		
		//scale speeds based on degrees. Why not an exponential function? :(
		if(degrees_to_abs <= 180)
		{
			setSpeed = 1;
		}
		if(degrees_to_abs < 90)
		{
			setSpeed = 0.4;
		}
		if(degrees_to_abs < 60)
		{
			setSpeed = 0.3;
		}
		if(degrees_to_abs < 30)
		{
			setSpeed = 0.2;
		}
		
		// Convert fron absolute angle back to direction based
		RotCmd = spinDirection * setSpeed; 
		// Multiply in a master speed scaling factpr that was passed in if needed
		RotCmd = RotCmd * setinitSpeed; //just in case.
		
		times_through_loop = 1;
		
		printf("\n(DriveRotateLoop) SpinCW = %d     SpinCCW = %d     SpinDir = %f     RotCmd = %3.2f\n", TooFarCCW, TooFarCW, spinDirection, RotCmd);
		
	}
	
	
	// If we didn't need to spin, we can end the command now.
	else {
		printf("\n(DriveRotateLoop) Didn't need to spin.");
		if(times_through_loop == LOOP_IT_CHECK || times_through_loop == 0)
		{
			rotateIsDone = true;
			times_through_loop = 0;
			RotCmd = 0;
			printf("\n(DriveRotateLoop) Spinning Can Stop Now ");
		}
		
		//the reason we implement the loop is because it allows us to check if the
		//robot is past the 0 degrees and if it doesn't then increment to loop
		//changes the amount of times for different robots.
		times_through_loop++;
		
	}
	
	printf("\n Leaving driveCommand::RotateToAngleDrive");
	return RotCmd;
}
// Make this return true when this Command no longer needs to run execute()
bool driveCommand::IsFinished() {
	printf("\n In driveCommand::IsFinished()");
	return false;
}

// Called once after isFinished returns true
void driveCommand::End() {
	printf("\n In driveCommand::End()");
	
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void driveCommand::Interrupted() {
	printf("\n In driveCommand::Interrupted()");

}
